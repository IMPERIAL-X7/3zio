{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-4392628e84f02b01a3a62083604d2b470be00f4f",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/burner_verfier.sol": "project/contracts/burner_verfier.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/burner_verfier.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./Verifier.sol\";\nimport \"./main.sol\";\nimport \"./data_types.sol\";\n\ncontract Burner_Verifier {\n    Main_Contract public real_contract;\n    Groth16Verifier public verifier;\n\n    constructor(address _contract, address _verifier) {\n        real_contract = Main_Contract(_contract);\n        verifier = Groth16Verifier(_verifier);\n    }\n\n    function BurnerVerifier(Proof calldata proof) external payable {\n        // Step 1: verify proof\n        // Verifier expects: uint[2] _pA, uint[2][2] _pB, uint[2] _pC, uint[5] _pubSignals\n        bool verified = verifier.verifyProof(\n            proof.A,\n            proof.B,\n            proof.C,\n            [proof._publicSignals[0], proof._publicSignals[1], proof._publicSignals[2], \n             proof._publicSignals[3], proof._publicSignals[4]]\n        );\n        require(verified, \"Invalid proof\");\n        // require(info.valid_rp, \"Invalid range proof\");\n        \n        balance_data memory balances = real_contract.getbalance(msg.sender);\n        require(proof._publicSignals[0] == balances.pub_balance, \"Invalid current public balance\");\n        require(proof._publicSignals[1] == balances.priv_balance, \"Invalid current private balances\");\n\n        // Step 2: update balance in Main_Contract\n        real_contract.burner(msg.sender, proof._publicSignals[0], proof._publicSignals[2], proof._publicSignals[4]);\n    }\n}"
      },
      "project/contracts/data_types.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nstruct balance_data {\n    uint256 pub_balance;\n    uint256 priv_balance;\n}\n\nstruct proof_data_A {\n    bool valid_rp;\n    uint256 new_priv_balance;\n    uint256 nullifier; //hash of pub,priv_balance(salt) + amt + r \n    uint256 amt_r_hash;\n    uint256 curr_priv_balance;\n    uint256 curr_pub_balance;\n}\n\nstruct proof_data_B{\n    uint256 old_pub_balance;\n    uint256 old_priv_balance;\n    uint256 updated_pub_balance;\n}\n\nstruct Proof{\n    uint256[2] A;\n    uint256[2][2] B;\n    uint256[2] C;\n    uint256[] _publicSignals; // pub. bal, old commitment, new commitment, amt_r_hash, nullifier\n}\n\nstruct ProofB{\n    uint256[2] A;\n    uint256[2][2] B;\n    uint256[2] C;\n    uint256[] _publicSignals; // old commitment, new commitment, amt_r_hash (3 signals for Circuit B)\n}"
      },
      "project/contracts/main.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./data_types.sol\";\n\ncontract Main_Contract{\n\n    mapping (address => balance_data) private balances;\n    address public burn_controller; // ConditionalBurner contract\n    address public mint_controller; // ConditionalMinter contract\n    address public owner;\n\n    // Set of uint256 values\n    mapping(uint256 => bool) private unminted_proofs;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    modifier onlyBurner() {\n        require(msg.sender == burn_controller, \"Not authorized\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == mint_controller, \"Not authorized\");\n        _;        \n    }\n\n    function getbalance(address user) external view returns (balance_data memory) {\n        return balances[user];\n    }\n\n    // internal updater used by both the owner and the controller path\n    function _setbalance(address user, uint256 pub_balance, uint256 priv_balance) internal {\n        balances[user] = balance_data(pub_balance, priv_balance);\n    }\n\n    function burner(address user, uint256 curr_pub_balance, uint256 new_priv_balance, uint256 nullifier) external payable onlyBurner{\n        _setbalance(user, curr_pub_balance, new_priv_balance);\n        unminted_proofs[nullifier] = true;\n    }\n\n    function minter(address user, uint256 curr_pub_balance, uint256 new_priv_balance, uint256 nullifier) external payable onlyMinter{\n        require(unminted_proofs[nullifier], \"Proof already used\");\n        _setbalance(user, curr_pub_balance, new_priv_balance);\n        unminted_proofs[nullifier] = false;\n    }\n\n    // Setter functions for controllers\n    function setBurnController(address _controller) external onlyOwner {\n        burn_controller = _controller;\n    }\n\n    function setMintController(address _controller) external onlyOwner {\n        mint_controller = _controller;\n    }\n}"
      },
      "project/contracts/Verifier.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n    // Scalar field size\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 8747521778521220622802447035163334522226340459921539082327713962685745757396;\n    uint256 constant alphay  = 18252424854090204816159487773075484706571756562065203630886938741088109069589;\n    uint256 constant betax1  = 8159812955823361518634371010471380723972068807658206686507042042232554112042;\n    uint256 constant betax2  = 224492243855771818182940915838841428917995530816631330277011486392787011836;\n    uint256 constant betay1  = 15348387451758448603233166618499814151460872734002687953319435599164157062982;\n    uint256 constant betay2  = 889632281894622345479989721097352592696186315059436408200924113883729366490;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant deltax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant deltay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant deltay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n\n    \n    uint256 constant IC0x = 18747882759360640156661049013115873255270868656152789822474910960621960075938;\n    uint256 constant IC0y = 21476675622477139705354844600248771349950198451332627599442326243337554545049;\n    \n    uint256 constant IC1x = 12163888022476368071795532852415900122031995485487024203249034485438974694939;\n    uint256 constant IC1y = 2079877012696477604036554830183332143777661199538405123102435606922840347383;\n    \n    uint256 constant IC2x = 547066745897504894544661661195452889485154500626435034358126467588264510270;\n    uint256 constant IC2y = 10573226175411646374246124913534559598183677635850152302180719576364134991621;\n    \n    uint256 constant IC3x = 11697193086239014394349078568491064328770051368886405348916883957810825966799;\n    uint256 constant IC3y = 20745153655519473266401005176990506421384370647040121334229875402374326346673;\n    \n    uint256 constant IC4x = 4295545633920251309967936506889331028619127527116886397992629110181972001144;\n    uint256 constant IC4y = 11746409821107345439739576458111559571030251034628179393187886168136622992576;\n    \n    uint256 constant IC5x = 10248491104980475328562740685344976467910086209482049982612941478905414299413;\n    uint256 constant IC5y = 166205531937018075307871537465865950968412533512744749428087922493593587982;\n    \n \n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[5] calldata _pubSignals) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, r)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n            \n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n                \n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                \n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n                \n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n                \n                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))\n                \n                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))\n                \n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n            \n            checkField(calldataload(add(_pubSignals, 0)))\n            \n            checkField(calldataload(add(_pubSignals, 32)))\n            \n            checkField(calldataload(add(_pubSignals, 64)))\n            \n            checkField(calldataload(add(_pubSignals, 96)))\n            \n            checkField(calldataload(add(_pubSignals, 128)))\n            \n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n             return(0, 0x20)\n         }\n     }\n }\n"
      }
    }
  }
}